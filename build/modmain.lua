local _G = GLOBAL
local pcall = _G.pcall
local getmetatable = _G.getmetatable
local getmetatable = _G.getmetatable
local setmetatable = _G.setmetatable
local rawset = _G.rawset
local select = _G.select
local debug = _G.debug
-- Generated by Haxe 3.4.2 (git build master @ 890f8c7)
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local Array = _hx_e()
local Main = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local haxe = {}
haxe.IMap = _hx_e()
haxe.ds = {}
haxe.ds.Either = _hx_e()
haxe.ds.StringMap = _hx_e()
haxe.io = {}
haxe.io.Eof = _hx_e()
local lua = {}
lua.Boot = _hx_e()
local utils = {}
utils.Debug = _hx_e()
utils.Lua = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = {}
Array.prototype = _hx_a(
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
)

Main.new = {}
Main.main = function() 
  utils.Debug.setup();
  env.AddClassPostConstruct("components/playercontroller",function(_self) 
    _self.GetAttackTarget = function(self,force,target,retry) 
      local value = haxe.ds.Either.Right(_self.inst);
      local truthyRepl = haxe.ds.Either.Left(function(p) 
        do return p.prefab end;
      end);
      local player;
      local value1 = value[1];
      if (value1) == 0 then 
        local fn = value[2];
        player = fn();
      elseif (value1) == 1 then 
        local v = value[2];
        player = v; end;
      local tmp;
      local tmp1;
      local tmp2;
      local value2 = haxe.ds.Either.Left(function() 
        do return player:HasTag("playerghost") end;
      end);
      local truthyRepl1 = haxe.ds.Either.Right("dead");
      local tmp3;
      local value3 = value2[1];
      if (value3) == 0 then 
        local fn1 = value2[2];
        tmp3 = fn1();
      elseif (value3) == 1 then 
        local v1 = value2[2];
        tmp3 = v1; end;
      if (not tmp3) then 
        local value4 = haxe.ds.Either.Left(function() 
          do return player.replica.inventory:IsHeavyLifting() end;
        end);
        local truthyRepl2 = haxe.ds.Either.Right("VERY");
        local value5 = value4[1];
        if (value5) == 0 then 
          local fn2 = value4[2];
          tmp2 = fn2();
        elseif (value5) == 1 then 
          local v2 = value4[2];
          tmp2 = v2; end;
      else
        tmp2 = true;
      end;
      if (not tmp2) then 
        local value6 = haxe.ds.Either.Right(nil == player.replica.combat);
        local truthyRepl3 = haxe.ds.Either.Right("NO");
        local value7 = value6[1];
        if (value7) == 0 then 
          local fn3 = value6[2];
          tmp1 = fn3();
        elseif (value7) == 1 then 
          local v3 = value6[2];
          tmp1 = v3; end;
      else
        tmp1 = true;
      end;
      if (not tmp1) then 
        local b;
        local value8 = haxe.ds.Either.Right(nil ~= player.sg);
        local truthyRepl4 = haxe.ds.Either.Right("a");
        local b1;
        local value9 = value8[1];
        if (value9) == 0 then 
          local fn4 = value8[2];
          b1 = fn4();
        elseif (value9) == 1 then 
          local v4 = value8[2];
          b1 = v4; end;
        if (b1) then 
          local value10 = haxe.ds.Either.Left(function() 
            do return player.sg:HasStateTag("attack") end;
          end);
          local truthyRepl5 = haxe.ds.Either.Right("IS");
          local b2;
          local value11 = value10[1];
          if (value11) == 0 then 
            local fn5 = value10[2];
            b2 = fn5();
          elseif (value11) == 1 then 
            local v5 = value10[2];
            b2 = v5; end;
          if (not b2) then 
            local value12 = haxe.ds.Either.Left(function() 
              do return player:HasTag("attack") end;
            end);
            local truthyRepl6 = haxe.ds.Either.Right("HAS");
            local value13 = value12[1];
            if (value13) == 0 then 
              local fn6 = value12[2];
              b = fn6();
            elseif (value13) == 1 then 
              local v6 = value12[2];
              b = v6; end;
          else
            b = true;
          end;
        else
          b = false;
        end;
        local value14 = haxe.ds.Either.Right(b);
        local truthyRepl7 = haxe.ds.Either.Right("IS");
        local value15 = value14[1];
        if (value15) == 0 then 
          local fn7 = value14[2];
          tmp = fn7();
        elseif (value15) == 1 then 
          local v7 = value14[2];
          tmp = v7; end;
      else
        tmp = true;
      end;
      if (tmp) then 
        do return nil end;
      end;
      local _hx_1_playerCoords_x, _hx_1_playerCoords_y, _hx_1_playerCoords_z = player.Transform:GetWorldPosition();
      local attackRange = player.replica.combat:GetAttackRangeWithWeapon();
      local walkingRange = (function() 
        local _hx_2
        if (_self.directwalking) then 
        _hx_2 = attackRange; else 
        _hx_2 = attackRange + 6; end
        return _hx_2
      end )();
      local playerReach = (player.Physics:GetRadius() + walkingRange) + 0.1;
      local v8 = player.replica.inventory;
      local value16 = haxe.ds.Either.Right((function() 
        local _hx_3
        if (nil == v8) then 
        _hx_3 = nil; else 
        _hx_3 = v8:GetEquippedItem(_G.EQUIPSLOTS.HANDS); end
        return _hx_3
      end )());
      local truthyRepl8 = haxe.ds.Either.Left(function(item) 
        do return item.prefab end;
      end);
      local playerItemInHand;
      local value17 = value16[1];
      if (value17) == 0 then 
        local fn8 = value16[2];
        playerItemInHand = fn8();
      elseif (value17) == 1 then 
        local v9 = value16[2];
        playerItemInHand = v9; end;
      local value18 = haxe.ds.Either.Left(function() 
        if (player:HasTag("beaver")) then 
          do return true end;
        end;
        if (nil ~= playerItemInHand) then 
          local inventoryItem = playerItemInHand.replica.inventoryitem;
          if (nil ~= inventoryItem) then 
            if (inventoryItem:IsWeapon()) then 
              do return true end;
            end;
          end;
        end;
        do return false end;
      end);
      local truthyRepl9 = haxe.ds.Either.Right("true");
      local playerHasWeapon;
      local value19 = value18[1];
      if (value19) == 0 then 
        local fn9 = value18[2];
        playerHasWeapon = fn9();
      elseif (value19) == 1 then 
        local v10 = value18[2];
        playerHasWeapon = v10; end;
      local nearestDist = nil;
      local interests = haxe.ds.StringMap.new();
      local ValidAttackTarget = function(target1) 
        local valid;
        local valid1;
        local valid2;
        local value20 = haxe.ds.Either.Right(nil ~= target1);
        local truthyRepl10 = haxe.ds.Either.Left(function(_) 
          do return target1.prefab end;
        end);
        local valid3;
        local value21 = value20[1];
        if (value21) == 0 then 
          local fn10 = value20[2];
          valid3 = fn10();
        elseif (value21) == 1 then 
          local v11 = value20[2];
          valid3 = v11; end;
        if (valid3) then 
          local value22 = haxe.ds.Either.Right(nil ~= target1.replica.combat);
          local truthyRepl11 = haxe.ds.Either.Right("has");
          local value23 = value22[1];
          if (value23) == 0 then 
            local fn11 = value22[2];
            valid2 = fn11();
          elseif (value23) == 1 then 
            local v12 = value22[2];
            valid2 = v12; end;
        else
          valid2 = false;
        end;
        if (valid2) then 
          local valid4;
          local value24 = haxe.ds.Either.Right(retry);
          local truthyRepl12 = haxe.ds.Either.Right("true");
          local valid5;
          local value25 = value24[1];
          if (value25) == 0 then 
            local fn12 = value24[2];
            valid5 = fn12();
          elseif (value25) == 1 then 
            local v13 = value24[2];
            valid5 = v13; end;
          if (not valid5) then 
            local value26 = haxe.ds.Either.Right(player.replica.combat:IsRecentTarget(target1));
            local truthyRepl13 = haxe.ds.Either.Right("is");
            local value27 = value26[1];
            if (value27) == 0 then 
              local fn13 = value26[2];
              valid4 = fn13();
            elseif (value27) == 1 then 
              local v14 = value26[2];
              valid4 = v14; end;
          else
            valid4 = true;
          end;
          if (not valid4) then 
            local valid6;
            local value28 = haxe.ds.Either.Right(nil == target1.replica.health);
            local truthyRepl14 = haxe.ds.Either.Right("was never alive");
            local valid7;
            local value29 = value28[1];
            if (value29) == 0 then 
              local fn14 = value28[2];
              valid7 = fn14();
            elseif (value29) == 1 then 
              local v15 = value28[2];
              valid7 = v15; end;
            if (not valid7) then 
              local valid8;
              local value30 = haxe.ds.Either.Right(not force);
              local truthyRepl15 = haxe.ds.Either.Right("is not");
              local valid9;
              local value31 = value30[1];
              if (value31) == 0 then 
                local fn15 = value30[2];
                valid9 = fn15();
              elseif (value31) == 1 then 
                local v16 = value30[2];
                valid9 = v16; end;
              if (valid9) then 
                local value32 = haxe.ds.Either.Left(function() 
                  do return target1.replica.combat:GetTarget() ~= player end;
                end);
                local truthyRepl16 = haxe.ds.Either.Right("is not");
                local value33 = value32[1];
                if (value33) == 0 then 
                  local fn16 = value32[2];
                  valid8 = fn16();
                elseif (value33) == 1 then 
                  local v17 = value32[2];
                  valid8 = v17; end;
              else
                valid8 = false;
              end;
              if (valid8) then 
                local valid10;
                local valid11;
                local valid12;
                local value34 = haxe.ds.Either.Left(function() 
                  do return not target1:HasTag("hostile") end;
                end);
                local truthyRepl17 = haxe.ds.Either.Right("is not");
                local valid13;
                local value35 = value34[1];
                if (value35) == 0 then 
                  local fn17 = value34[2];
                  valid13 = fn17();
                elseif (value35) == 1 then 
                  local v18 = value34[2];
                  valid13 = v18; end;
                if (not valid13) then 
                  local value36 = haxe.ds.Either.Left(function() 
                    do return player.replica.combat:IsAlly(target1) end;
                  end);
                  local truthyRepl18 = haxe.ds.Either.Right("is");
                  local value37 = value36[1];
                  if (value37) == 0 then 
                    local fn18 = value36[2];
                    valid12 = fn18();
                  elseif (value37) == 1 then 
                    local v19 = value36[2];
                    valid12 = v19; end;
                else
                  valid12 = true;
                end;
                if (not valid12) then 
                  local value38 = haxe.ds.Either.Right(not playerHasWeapon);
                  local truthyRepl19 = haxe.ds.Either.Right("has no");
                  local valid14;
                  local value39 = value38[1];
                  if (value39) == 0 then 
                    local fn19 = value38[2];
                    valid14 = fn19();
                  elseif (value39) == 1 then 
                    local v20 = value38[2];
                    valid14 = v20; end;
                  if (valid14) then 
                    local value40 = haxe.ds.Either.Left(function() 
                      do return target1:HasTag("monster") end;
                    end);
                    local truthyRepl20 = haxe.ds.Either.Right("is");
                    local value41 = value40[1];
                    if (value41) == 0 then 
                      local fn20 = value40[2];
                      valid11 = fn20();
                    elseif (value41) == 1 then 
                      local v21 = value40[2];
                      valid11 = v21; end;
                  else
                    valid11 = false;
                  end;
                else
                  valid11 = true;
                end;
                if (not valid11) then 
                  local value42 = haxe.ds.Either.Left(function() 
                    do return target1:HasTag("player") end;
                  end);
                  local truthyRepl21 = haxe.ds.Either.Right("is");
                  local value43 = value42[1];
                  if (value43) == 0 then 
                    local fn21 = value42[2];
                    valid10 = fn21();
                  elseif (value43) == 1 then 
                    local v22 = value42[2];
                    valid10 = v22; end;
                else
                  valid10 = true;
                end;
                if (not valid10) then 
                  local valid15;
                  local valid16;
                  local value44 = haxe.ds.Either.Right(nil ~= target1.replica.follower);
                  local truthyRepl22 = haxe.ds.Either.Right("is");
                  local valid17;
                  local value45 = value44[1];
                  if (value45) == 0 then 
                    local fn22 = value44[2];
                    valid17 = fn22();
                  elseif (value45) == 1 then 
                    local v23 = value44[2];
                    valid17 = v23; end;
                  if (valid17) then 
                    local value46 = haxe.ds.Either.Left(function() 
                      do return nil ~= target1.replica.follower:GetLeader() end;
                    end);
                    local truthyRepl23 = haxe.ds.Either.Right("a");
                    local value47 = value46[1];
                    if (value47) == 0 then 
                      local fn23 = value46[2];
                      valid16 = fn23();
                    elseif (value47) == 1 then 
                      local v24 = value46[2];
                      valid16 = v24; end;
                  else
                    valid16 = false;
                  end;
                  if (valid16) then 
                    local value48 = haxe.ds.Either.Left(function() 
                      do return target1.replica.follower:GetLeader():HasTag("player") end;
                    end);
                    local truthyRepl24 = haxe.ds.Either.Right("is");
                    local value49 = value48[1];
                    if (value49) == 0 then 
                      local fn24 = value48[2];
                      valid15 = fn24();
                    elseif (value49) == 1 then 
                      local v25 = value48[2];
                      valid15 = v25; end;
                  else
                    valid15 = false;
                  end;
                  if (valid15) then 
                    local value50 = haxe.ds.Either.Left(function() 
                      do return target1.replica.follower:GetLeader().replica.combat:GetTarget() ~= player end;
                    end);
                    local truthyRepl25 = haxe.ds.Either.Right("is not");
                    local value51 = value50[1];
                    if (value51) == 0 then 
                      local fn25 = value50[2];
                      valid6 = fn25();
                    elseif (value51) == 1 then 
                      local v26 = value50[2];
                      valid6 = v26; end;
                  else
                    valid6 = false;
                  end;
                else
                  valid6 = true;
                end;
              else
                valid6 = false;
              end;
            else
              valid6 = true;
            end;
            valid1 = not valid6;
          else
            valid1 = true;
          end;
        else
          valid1 = false;
        end;
        if (valid1) then 
          local valid18;
          local valid19;
          local valid20;
          local value52 = haxe.ds.Either.Left(function() 
            do return not player.replica.combat:CanTarget(target1) end;
          end);
          local truthyRepl26 = haxe.ds.Either.Right("CANNOT");
          local valid21;
          local value53 = value52[1];
          if (value53) == 0 then 
            local fn26 = value52[2];
            valid21 = fn26();
          elseif (value53) == 1 then 
            local v27 = value52[2];
            valid21 = v27; end;
          if (not valid21) then 
            local value54 = haxe.ds.Either.Left(function() 
              do return target1.replica.health:IsDead() end;
            end);
            local truthyRepl27 = haxe.ds.Either.Right("has");
            local value55 = value54[1];
            if (value55) == 0 then 
              local fn27 = value54[2];
              valid20 = fn27();
            elseif (value55) == 1 then 
              local v28 = value54[2];
              valid20 = v28; end;
          else
            valid20 = true;
          end;
          if (not valid20) then 
            local value56 = haxe.ds.Either.Left(function() 
              do return not _G.CanEntitySeeTarget(player,target1) end;
            end);
            local truthyRepl28 = haxe.ds.Either.Right("CANNOT");
            local value57 = value56[1];
            if (value57) == 0 then 
              local fn28 = value56[2];
              valid19 = fn28();
            elseif (value57) == 1 then 
              local v29 = value56[2];
              valid19 = v29; end;
          else
            valid19 = true;
          end;
          if (not valid19) then 
            if (nil ~= playerItemInHand) then 
              if (not (((playerItemInHand.prefab == "icestaff") and (nil ~= target1.components.freezable)) and target1.components.freezable:IsFrozen())) then 
                if ((playerItemInHand.prefab == "firestaff") and (nil ~= target1.components.burnable)) then 
                  valid18 = target1.components.burnable:IsBurning();
                else
                  valid18 = false;
                end;
              else
                valid18 = true;
              end;
            else
              valid18 = false;
            end;
          else
            valid18 = true;
          end;
          valid = not valid18;
        else
          valid = false;
        end;
        if (not valid) then 
          do return false end;
        end;
        local targetDistToPlayer = target1:GetDistanceSqToPoint(_hx_1_playerCoords_x,0,_hx_1_playerCoords_z);
        local playerReachPlusTargetRadius = (function() 
          local _hx_4
          if (nil == target1.Physics) then 
          _hx_4 = 0; else 
          _hx_4 = target1.Physics:GetRadius(); end
          return _hx_4
        end )();
        local playerReachPlusTargetRadius1 = _G.math.pow(playerReach + playerReachPlusTargetRadius,2);
        if (valid) then 
          local value58 = haxe.ds.Either.Right(targetDistToPlayer > playerReachPlusTargetRadius1);
          local truthyRepl29 = haxe.ds.Either.Right("is");
          local valid22;
          local value59 = value58[1];
          if (value59) == 0 then 
            local fn29 = value58[2];
            valid22 = fn29();
          elseif (value59) == 1 then 
            local v30 = value58[2];
            valid22 = v30; end;
          valid = not valid22;
        else
          valid = false;
        end;
        if (not valid) then 
          do return false end;
        end;
        if ((nil == nearestDist) or (nearestDist > targetDistToPlayer)) then 
          nearestDist = targetDistToPlayer;
          interests.v["nearest"] = target1;
          interests.k["nearest"] = true;
        end;
        local nepi = function(s) 
          local nepi1;
          if (not (not (interests.k[s] or false))) then 
            local nepi2 = interests.v[s]:GetDistanceSqToPoint(_hx_1_playerCoords_x,0,_hx_1_playerCoords_z);
            nepi1 = targetDistToPlayer < nepi2;
          else
            nepi1 = true;
          end;
          if (nepi1) then 
            interests.v[s] = target1;
            interests.k[s] = true;
          end;
        end;
        nepi(target1.prefab);
        if (("spider" == target1.prefab) and target1:HasTag("attack")) then 
          nepi("spider_attack");
        end;
        do return true end;
      end;
      if (ValidAttackTarget(target)) then 
        do return target end;
      end;
      target = nil;
      retry = false;
      local value60 = haxe.ds.Either.Left(function() 
        do return _G.TheSim:FindEntities(_hx_1_playerCoords_x,_hx_1_playerCoords_y,_hx_1_playerCoords_z,walkingRange + 5,_hx_tab_array({[0]="_combat" }, 1),_hx_tab_array({[0]="INLIMBO" }, 1)) end;
      end);
      local truthyRepl30 = haxe.ds.Either.Left(function(t) 
        do return Std.string(utils.Lua.count(t)) end;
      end);
      local nearbyEntities;
      local value61 = value60[1];
      if (value61) == 0 then 
        local fn30 = value60[2];
        nearbyEntities = fn30();
      elseif (value61) == 1 then 
        local v31 = value60[2];
        nearbyEntities = v31; end;
      local pair = utils.Lua.ipairs(nearbyEntities);
      local _hx_break_0 = false;
      while (pair:hasNext()) do 
        repeat 
        local pair1 = pair:next();
        local entity = pair1.value;
        if (entity == player) then 
          break;
        end;
        local value62 = haxe.ds.Either.Right(entity);
        local truthyRepl31 = (function() 
          local _hx_5
          if (nil == entity) then 
          _hx_5 = haxe.ds.Either.Right("?"); else 
          _hx_5 = haxe.ds.Either.Right(entity.prefab); end
          return _hx_5
        end )();
        local value63 = value62[1];
        if (value63) == 0 then 
          local fn31 = value62[2];
          fn31();
        elseif (value63) == 1 then 
          local v32 = value62[2]; end;
        local tmp4 = ValidAttackTarget(entity);
        
      until true
      if _hx_break_1 then _hx_break_1 = false; break; end
      end;
      local nearby = function(a) 
        local _g = 0;
        while (_g < a.length) do 
          local k = a[_g];
          _g = _g + 1;
          local v33 = interests.v[k];
          if (nil ~= v33) then 
            target = v33;
            do return true end;
          end;
          end;
        do return false end;
      end;
      local weap = function(prefabNames) 
        if (nil == playerItemInHand) then 
          do return false end;
        end;
        local _g1 = 0;
        while (_g1 < prefabNames.length) do 
          local name = prefabNames[_g1];
          _g1 = _g1 + 1;
          if (name == playerItemInHand.prefab) then 
            do return true end;
          end;
          end;
        do return false end;
      end;
      if (not ((((weap(_hx_tab_array({[0]="icestaff" }, 1)) and nearby(_hx_tab_array({[0]="walrus", "canary", "robin_winter", "robin", "crow" }, 5))) or (weap(_hx_tab_array({[0]="blowdart_pipe" }, 1)) and nearby(_hx_tab_array({[0]="icehound", "hound", "firehound" }, 3)))) or (weap(_hx_tab_array({[0]="boomerang" }, 1)) and nearby(_hx_tab_array({[0]="deerclops", "bearger", "walrus", "canary", "robin_winter", "robin", "crow" }, 7)))) or nearby(_hx_tab_array({[0]="spider_attack" }, 1)))) then 
        target = interests.v["nearest"];
      end;
      local value64 = haxe.ds.Either.Right(target);
      local truthyRepl32 = haxe.ds.Either.Left(function(t1) 
        do return t1.prefab .. " at " .. nearestDist end;
      end);
      local value65 = value64[1];
      if (value65) == 0 then 
        local fn32 = value64[2];
        fn32();
      elseif (value65) == 1 then 
        local v34 = value64[2]; end;
      do return target end
     end;
  end);
end

String.new = {}
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'toString', function(self) 
    do return self end
  end
)

Std.new = {}
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end

haxe.IMap.new = {}

haxe.ds.Either.Left = function(v) local _x = _hx_tab_array({[0]="Left",0,v,__enum__=haxe.ds.Either}, 3); return _x; end 
haxe.ds.Either.Right = function(v) local _x = _hx_tab_array({[0]="Right",1,v,__enum__=haxe.ds.Either}, 3); return _x; end 

haxe.ds.StringMap.new = function() 
  local self = _hx_new()
  haxe.ds.StringMap.super(self)
  return self
end
haxe.ds.StringMap.super = function(self) 
  self.v = {}
  self.k = {}
end
haxe.ds.StringMap.__interfaces__ = {haxe.IMap}

haxe.io.Eof.new = {}
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
)

lua.Boot.new = {}
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end

utils.Debug.new = {}
utils.Debug.setup = function() 
end

utils.Lua.new = {}
utils.Lua.ipairs = function(table) 
  local i = 1;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local i1 = i;
    i = i + 1;
    do return _hx_o({__fields__={index=true,value=true},index=i1,value=table[i - 1]}) end;
  end,hasNext=function(self) 
    do return nil ~= table[i] end;
  end}) end;
end
utils.Lua.count = function(table) 
  local i = 0;
  while (true) do 
    i = i + 1;
    if (not (nil ~= table[i])) then 
      break;
    end;
    end;
  do return i - 2 end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
end

_hx_static_init();
Main.main()
return _hx_exports
